import { SignJWT, jwtVerify } from "jose";
import type { JWTPayload } from "jose";

// Support for external tokens - if EXTERNAL_JWT_SECRET is set, use it for verification
// Otherwise, use internal secret for both signing and verification
const internalSecret = process.env.JWT_SECRET ?? "srs-vehicle-management-secret";
const externalSecret = process.env.EXTERNAL_JWT_SECRET;

const jwtSecret = new TextEncoder().encode(internalSecret);
const externalJwtSecret = externalSecret ? new TextEncoder().encode(externalSecret) : null;

const MICROSOFT_ROLE_CLAIM = "http://schemas.microsoft.com/ws/2008/06/identity/claims/role";

export interface AuthPayload extends JWTPayload {
  username: string;
  role: "Admin";
  // Microsoft-style claims (for external tokens)
  unique_name?: string;
  sub?: string;
  [MICROSOFT_ROLE_CLAIM]?: string;
}

export async function signAuthToken(payload: AuthPayload) {
  return new SignJWT(payload)
    .setProtectedHeader({ alg: "HS256" })
    .setIssuedAt()
    .setExpirationTime("8h")
    .sign(jwtSecret);
}

export async function verifyAuthToken(token: string) {
  // Try internal secret first (for tokens generated by this app)
  try {
    const { payload } = await jwtVerify(token, jwtSecret);
    return normalizePayload(payload);
  } catch {
    // If internal secret fails and external secret is configured, try external secret
    if (externalJwtSecret) {
      try {
        const { payload } = await jwtVerify(token, externalJwtSecret);
        return normalizePayload(payload);
      } catch {
        // Both secrets failed - token is invalid
        return null;
      }
    }
    // No external secret configured and internal verification failed
    return null;
  }
}

function normalizePayload(payload: unknown) {
  // Normalize the payload to handle both internal and Microsoft-style tokens
  const normalizedPayload = payload as Record<string, unknown> & {
    unique_name?: string;
    username?: string;
    role?: string;
    [MICROSOFT_ROLE_CLAIM]?: string;
    sub?: string;
    iat?: number;
    exp?: number;
  };

  // Extract username from either 'username' or 'unique_name'
  const username = normalizedPayload.username ?? normalizedPayload.unique_name;
  
  // Extract role from either 'role' or Microsoft claim
  const role = normalizedPayload.role ?? normalizedPayload[MICROSOFT_ROLE_CLAIM];

  // If we don't have username, token is invalid
  if (!username || typeof username !== "string") {
    return null;
  }

  // Role is optional - if not present, default to Admin for backward compatibility
  const userRole = role && typeof role === "string" ? role : "Admin";

  // Return normalized payload
  return {
    username,
    role: userRole as "Admin",
    sub: normalizedPayload.sub,
    iat: normalizedPayload.iat,
    exp: normalizedPayload.exp,
  } as AuthPayload & {
    iat?: number;
    exp?: number;
  };
}
